(ns my-project-euler-lab.core_pb_12
  (:use [clojure.test               :only [run-tests]])
  (:use [midje.sweet])
  (:use [clojure.contrib.repl-utils :only [show]])
  (:use [clojure.pprint             :only [pprint]])
  (:use [clojure.walk               :only [macroexpand-all]])
  (:use clojure.contrib.math))

;The sequence of triangle numbers is generated by adding the natural numbers. So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The first ten terms would be:

;1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...

;Let us list the factors of the first seven triangle numbers:

;     1: 1
;     3: 1,3
;     6: 1,2,3,6
;    10: 1,2,5,10
;    15: 1,3,5,15
;    21: 1,3,7,21
;    28: 1,2,4,7,14,28

;We can see that 28 is the first triangle number to have over five divisors.

;What is the value of the first triangle number to have over five
;hundred divisors?

; solution

;we can see that the triangle series is like this
;1
;1+2   => 3
;3+3   => 6
;6+4   => 10
;10+5  => 15
;15+6  => 21
;...
;45+15 => 55

;Idea: Generate such a sequence so that we spare the computing time
;for the sum

;+  1 3 6  10 15 21 28 36 45 55
;(1 2 3 4   5  6  7  8  9 10 ...)
; 1 3 6 10 15 21 28 36 45 55 ...

(defn all-divisors "Compute all divisors of a number"
  [n]
  (cond
   (zero? n) "infinity"
   (= 1 n) [n]
   :else
   (sort (distinct (map #(gcd n %) (range 2 (inc n)))))))

(fact
  (all-divisors 0) => "infinity"
  (all-divisors 1) => [1] 
  (all-divisors 10) => [1 2 5 10]
  (all-divisors 15) => [1 3 5 15]
  (all-divisors 21) => [1 3 7 21]
  (all-divisors 28) => [1 2 4 7 14 28]
  )

(defn count-all-divisors "Count all the divisors of a number"
  [n]
  (cond
   (zero? n) "infinity"
   (= 1 n) 1
   :else
   (loop [cpt 1 nb-divisors 1]
     (if (= cpt n)
       nb-divisors
       (if (zero? (rem n cpt))
         (recur (inc cpt) (inc nb-divisors))
         (recur (inc cpt) nb-divisors))))))

(fact
  (count-all-divisors 0)  => "infinity"
  (count-all-divisors 1)  => 1 
  (count-all-divisors 10) => 4
  (count-all-divisors 15) => 4
  (count-all-divisors 21) => 4
  (count-all-divisors 28) => 6
  )

(defn gen-triangle-nat "Compute the first natural number to have nb-divisors divisors."
  [nb-divisors]
  (loop [curr 0 num-nat 1]
    (let [cpt-triangle-nat (+ curr num-nat)]
      (if (<= nb-divisors (count-all-divisors cpt-triangle-nat))
        cpt-triangle-nat
        (recur cpt-triangle-nat (inc num-nat))
        ))))

; too violent for computing 500 divisors

;.;. Work joyfully and peacefully, knowing that right thoughts and right
;.;. efforts will inevitably bring about right results. -- Allen
(fact
  (gen-triangle-nat 5) => 28
  (gen-triangle-nat 500) => 28
 )

