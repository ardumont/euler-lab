(ns my-project-euler-lab.core-pb-12
  (:use [clojure.test               :only [run-tests]])
  (:use [midje.sweet])
  (:use [clojure.contrib.repl-utils :only [show]])
  (:use [clojure.pprint             :only [pprint]])
  (:use [clojure.walk               :only [macroexpand-all]])
  (:use clojure.contrib.math)
  (:use [my-project-euler-lab.primes :only [lazy-primes prime-numbers-improved]]))

;; The sequence of triangle numbers is generated by adding the natural
;; numbers. So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. 
;; The first ten terms would be:
;; 1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...
;; Let us list the factors of the first seven triangle numbers:

;; 1: 1
;; 3: 1,3
;; 6: 1,2,3,6
;; 10: 1,2,5,10
;; 15: 1,3,5,15
;; 21: 1,3,7,21
;; 28: 1,2,4,7,14,28

;; We can see that 28 is the first triangle number to have over five divisors.
;; What is the value of the first triangle number to have over five
;; hundred divisors?

                                        ; solution

;we can see that the triangle series can be built like this:
;1
;1+2   => 3
;3+3   => 6
;6+4   => 10
;10+5  => 15
;15+6  => 21
;...
;45+15 => 55

;Idea: Generate such a sequence so that we spare the computing time
;for the sum

;+  1 3 6  10 15 21 28 36 45 55
;(1 2 3 4   5  6  7  8  9 10 ...)
; 1 3 6 10 15 21 28 36 45 55 ...

(defn all-divisors "Compute all divisors of a number"
  [n]
  (cond
   (zero? n) "infinity"
   (= 1 n) [n]
   :else
   (sort (distinct (map #(gcd n %) (range 2 (inc n)))))))

;.;. For every disciplined effort, there is a multiple reward. -- Rohn
(fact
  (all-divisors 0) => "infinity"
  (all-divisors 1) => [1]
  (all-divisors 10) => [1 2 5 10]
  (all-divisors 15) => [1 3 5 15]
  (all-divisors 21) => [1 3 7 21]
  (all-divisors 28) => [1 2 4 7 14 28]
  (all-divisors 120) => [1 2 3 4 5 6 8 10 12 15 20 24 30 40 60 120]
  )

(defn count-all-divisors-simple "Count all the divisors of a number."
  [n]
  (cond
   (zero? n) "infinity"
   (= 1 n) 1
   :else
   (loop [cpt 1 nb-divisors 1]
     (if (= cpt n)
       nb-divisors
       (if (zero? (rem n cpt))
         (recur (inc cpt) (inc nb-divisors))
         (recur (inc cpt) nb-divisors))))))

(fact
  (count-all-divisors-simple 0)  => "infinity"
  (count-all-divisors-simple 1)  => 1 
  (count-all-divisors-simple 10) => 4
  (count-all-divisors-simple 15) => 4
  (count-all-divisors-simple 21) => 4
  (count-all-divisors-simple 28) => 6
  )

(def litte-primes (prime-numbers-improved 28))
(fact litte-primes => [2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97 101 103 107])

(defn count-divisors-with-dec-prime "Compute the number of divisors with the help of the decomposition in prime numbers."
  [primes n]
  (cond
   (<= n 1) 0;principles -> infinity
   :else
   (loop [nb-divisors 1, cnt-exp 0, acc-div-primes primes, num n]
     (if (= 1 num)
       (* nb-divisors (inc cnt-exp))
       (let [divisor-prime (first acc-div-primes)]
         (if (zero? (rem num divisor-prime))
           (recur nb-divisors (inc cnt-exp) acc-div-primes (/ num divisor-prime))
           (recur (* nb-divisors (inc cnt-exp)) 0 (rest acc-div-primes) num)))))))

(fact
 (count-divisors-with-dec-prime [] 1) => 0
 (count-divisors-with-dec-prime [] 0) => 0
 (count-divisors-with-dec-prime litte-primes 10) => 4
 (count-divisors-with-dec-prime litte-primes 15) => 4
 (count-divisors-with-dec-prime litte-primes 21) => 4
 (count-divisors-with-dec-prime litte-primes 28) => 6
 (count-divisors-with-dec-prime (take 20 (lazy-primes)) 120) => 16
 )

(defn find-triangle-nat-with-n-divisors-from "Compute the first natural number to have nb-divisors divisors."
  [nb-divisors index-number-start triangle-number-start primes-seq]
  (loop [curr triangle-number-start num-nat (inc index-number-start)]
    (let [cpt-triangle-nat (+ curr num-nat)
          primes-sequence (take (ceil (sqrt cpt-triangle-nat)) primes-seq)
          nb-divisors-count (count-divisors-with-dec-prime primes-sequence cpt-triangle-nat)]
      (do #_(println "curr" curr "index-num-nat" num-nat "cpt-triangle-nat" cpt-triangle-nat "nb-divisors-count" nb-divisors-count "primes" primes-sequence)
          (if (<= nb-divisors nb-divisors-count)
            cpt-triangle-nat
            (recur cpt-triangle-nat (inc num-nat)))))))

(fact
  (find-triangle-nat-with-n-divisors-from 5  0 0 (lazy-primes)) => 28
  (find-triangle-nat-with-n-divisors-from 4  0 0 (lazy-primes)) => 6
  (find-triangle-nat-with-n-divisors-from 10 0 0 (lazy-primes)) => 120
  )

; factorisation with a closure
(defn find-triangle-nat-with-n-divisors "Compute the first natural number to have nb-divisors divisors."
  [nb-divisors]
  (find-triangle-nat-with-n-divisors-from nb-divisors 0 0 (lazy-primes)))

(fact
  (find-triangle-nat-with-n-divisors 5) => 28
  (find-triangle-nat-with-n-divisors 4) => 6
  (find-triangle-nat-with-n-divisors 10) => 120
;  (find-triangle-nat-with-n-divisors 500) => 28
  )

; have ideas to compute in another manner but complicated to implement
; (memory of multiples to refer in the next computing)

; so another approach with keeping the same algorithm
; 1) find a very large random triangle number n and start from it to
; find the one with 500 divisors.
; 2) if we find lots of numbers (to determine)  with more than 500
; multiples within a borne (to determine), go to 3) else continue the computation
; 3) we return to the half of the triangle number, find the next
; triangle number and go to 1)

(defn nth-triangle-nat "Compute the nth natural triangle and return the vector [n nth-triangle]"
  [n]
  [n (/ (* n (inc n)) 2)])

(fact
  (nth-triangle-nat 4) => [4 10]
  (nth-triangle-nat 5) => [5 15]
  (nth-triangle-nat 6) => [6 21]
  (nth-triangle-nat 7) => [7 28]
  )

(defn rand-triangle-nat "Generate a random triangle natural from the interval 1-n"
  [n]
  (nth-triangle-nat (ceil (rand n))))

(fact
  (find-triangle-nat-with-n-divisors 5) => 28
  (find-triangle-nat-with-n-divisors 4) => 6
  (find-triangle-nat-with-n-divisors 10) => 120
  )

; again make a closure
(defn find-triangle-nat-with-500-divisors "Find the triangle natural with 500 divisors."
  [nth-tri-nat]
  (let [tri-nat (nth-triangle-nat nth-tri-nat)
        triangle-nat (first tri-nat)
        index-nat (second tri-nat)]
    (find-triangle-nat-with-n-divisors-from 500 triangle-nat index-nat (lazy-primes))))

(fact
;  (find-triangle-nat-with-n-divisors 500) => 76576500
;  (find-triangle-nat-with-500-divisors 10000) => 76576500
  )
