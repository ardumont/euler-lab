(ns my-project-euler-lab.core-pb-12
  (:use [clojure.test               :only [run-tests]])
  (:use [midje.sweet])
  (:use [clojure.contrib.repl-utils :only [show]])
  (:use [clojure.pprint             :only [pprint]])
  (:use [clojure.walk               :only [macroexpand-all]])
  (:use clojure.contrib.math)
  (:use [my-project-euler-lab.play-with-primes :only [prime-numbers-improved]])
  )

;The sequence of triangle numbers is generated by adding the natural numbers. So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The first ten terms would be:

;1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...

;Let us list the factors of the first seven triangle numbers:

;     1: 1
;     3: 1,3
;     6: 1,2,3,6
;    10: 1,2,5,10
;    15: 1,3,5,15
;    21: 1,3,7,21
;    28: 1,2,4,7,14,28

;We can see that 28 is the first triangle number to have over five divisors.

;What is the value of the first triangle number to have over five
;hundred divisors?

; solution

;we can see that the triangle series can be built like this:
;1
;1+2   => 3
;3+3   => 6
;6+4   => 10
;10+5  => 15
;15+6  => 21
;...
;45+15 => 55

;Idea: Generate such a sequence so that we spare the computing time
;for the sum

;+  1 3 6  10 15 21 28 36 45 55
;(1 2 3 4   5  6  7  8  9 10 ...)
; 1 3 6 10 15 21 28 36 45 55 ...

(defn all-divisors "Compute all divisors of a number"
  [n]
  (cond
   (zero? n) "infinity"
   (= 1 n) [n]
   :else
   (sort (distinct (map #(gcd n %) (range 2 (inc n)))))))

(fact
  (all-divisors 0) => "infinity"
  (all-divisors 1) => [1]
  (all-divisors 10) => [1 2 5 10]
  (all-divisors 15) => [1 3 5 15]
  (all-divisors 21) => [1 3 7 21]
  (all-divisors 28) => [1 2 4 7 14 28]
  )

(defn count-all-divisors-simple "Count all the divisors of a number"
  [n]
  (cond
   (zero? n) "infinity"
   (= 1 n) 1
   :else
   (loop [cpt 1 nb-divisors 1]
     (if (= cpt n)
       nb-divisors
       (if (zero? (rem n cpt))
         (recur (inc cpt) (inc nb-divisors))
         (recur (inc cpt) nb-divisors))))))

(fact
  (count-all-divisors-simple 0)  => "infinity"
  (count-all-divisors-simple 1)  => 1 
  (count-all-divisors-simple 10) => 4
  (count-all-divisors-simple 15) => 4
  (count-all-divisors-simple 21) => 4
  (count-all-divisors-simple 28) => 6
  )

(defn count-all-divisors-primes "Count all the divisors of a number with the prime numbers."
  [primes n]
  (cond
   (zero? n) "infinity"
   (= 1 n) 1
   :else
   (loop [all-primes-left primes nb-divisors 2 num n]
     (if (= num 1)
       nb-divisors
       (let [prime (first all-primes-left)]
         (if (zero? (rem num prime))
           (recur all-primes-left (inc nb-divisors) (/ num prime))
           (recur (rest all-primes-left) nb-divisors num)))))))

;.;. FAIL at (NO_SOURCE_FILE:1)
;.;.     Expected: 6
;.;.       Actual: 5
(fact
 (count-all-divisors-primes (prime-numbers-improved 10) 10) => 4
 (count-all-divisors-primes (prime-numbers-improved 15) 15) => 4
 (count-all-divisors-primes (prime-numbers-improved 21) 21) => 4
 (count-all-divisors-primes (prime-numbers-improved 28) 28) => 6
 )

(defn count-all-divisors "Count all the divisors of a number"
  [n]
  (count-all-divisors-with-primes n (prime-numbers-improved (floor (sqrt n))))
  )

#_(fact
  (count-all-divisors 0)  => "infinity"
  (count-all-divisors 1)  => 1 
  (count-all-divisors 10 ) => 4
  (count-all-divisors 15) => 4
  (count-all-divisors 21) => 4
  (count-all-divisors 28) => 6
  )


#_(defn find-triangle-nat-with-n-divisors-from "Compute the first natural number to have nb-divisors divisors."
  [nb-divisors index-number-start triangle-number-start]
  (loop [curr triangle-number-start num-nat (inc index-number-start)]
    (let [cpt-triangle-nat (+ curr num-nat) nb-divisors-count (count-all-divisors cpt-triangle-nat) ]
      (do (println "curr" curr "index-num-nat" num-nat "cpt-triangle-nat" cpt-triangle-nat "nb-divisors-count" nb-divisors-count)
          (if (<= nb-divisors nb-divisors-count)
            cpt-triangle-nat
            (recur cpt-triangle-nat (inc num-nat)))))))

; factorisation with a closure
(defn find-triangle-nat-with-n-divisors "Compute the first natural number to have nb-divisors divisors."
  [nb-divisors]
  (find-triangle-nat-with-n-divisors-from nb-divisors 0 0))

#_(fact
  (find-triangle-nat-with-n-divisors 5) => 28
  (find-triangle-nat-with-n-divisors 4) => 6
  (find-triangle-nat-with-n-divisors 10) => 120
;  (find-triangle-nat-with-n-divisors 500) => 28
  )

; too violent to begin the computing at 0

; have ideas to compute in another manner but complicated to implement
; (memory of multiples to refer in the next computing)

; so another approach with keeping the same algorithm
; 1) find a very large random triangle number n and start from it to
; find the one with 500 divisors.
; 2) if we find lots of numbers (to determine)  with more than 500
; multiples within a borne (to determine), go to 3) else continue the computation
; 3) we return to the half of the triangle number, find the next
; triangle number and go to 1)

(defn nth-triangle-nat "Compute the nth natural triangle and return the vector [n nth-triangle]"
  [n]
  [n (/ (* n (inc n)) 2)])

; n=3 => 1/2 * n * (n + 1) = 6 = 2*3
; n=4 => 10 = 2 * 5
; n=5 => 15 = 3 * 5
; n=6 => 24 = 2 * 2 * 3 * 3
; n=7 => 28 = 2 * 2 * 7
; n=8 => 36 = 2 * 2 * 3 * 3
; n=9 => 45 = 5 * 9
; n=10 => 55 = 5 * 11
; n=11 => 66 = 6 * 11 = 2 * 3 * 11
; n=12 => 78 = 6 * 13 = 2 * 3 * 13
; n=13 => 91 = 2 * 45 = 2 * 3 * 3 * 5
; n=14 => 105 = 3 * 5 * 7
; ...

(fact
  (nth-triangle-nat 4) => [4 10]
  (nth-triangle-nat 5) => [5 15]
  (nth-triangle-nat 6) => [6 21]
  (nth-triangle-nat 7) => [7 28]
  )

(defn rand-triangle-nat "Generate a random triangle natural from the interval 1-n"
  [n]
  (nth-triangle-nat (ceil (rand n))))

#_(fact
  (find-triangle-nat-with-n-divisors-from 5 0 0) => 28
  (find-triangle-nat-with-n-divisors-from 4 0 0) => 6
  (find-triangle-nat-with-n-divisors-from 10 0 0) => 120
  )

; again make a closure
(defn find-triangle-nat-with-500-divisors "Find the triangle natural with 500 divisors."
  [nth-tri-nat]
  (let [tri-nat (nth-triangle-nat nth-tri-nat)
        triangle-nat (first tri-nat)
        index-nat (second tri-nat)]
    (find-triangle-nat-with-n-divisors-from 500 triangle-nat index-nat)))

;(find-triangle-nat-with-n-divisors-from 200 1224 748476) => 2031120
; => (+ 2029105 2015) => 2031120 with 240 divisors
;(find-triangle-nat-with-n-divisors-from 200 (first (nth-triangle-nat 1224)) (second (nth-triangle-nat 1224))) => 2031120
;(find-triangle-nat-with-n-divisors-from 300 (first (nth-triangle-nat
                                        ; 2025)) (second
    ; (nth-triangle-nat 2025))) => index 4030 ; 8124480 ; 336 divisors

;(find-triangle-nat-with-n-divisors-from 400 (first (nth-triangle-nat 4030)) (second (nth-triangle-nat 4030))) => 2031120

;(find-triangle-nat-with-n-divisors-from 400 (first (nth-triangle-nat 4935)) (second (nth-triangle-nat 4935)))
;=> 5983th triangle natural 17907210 with 480 divisors

;(find-triangle-nat-with-n-divisors-from 500 (first (nth-triangle-nat 5984)) (second (nth-triangle-nat 5984)))
; brute force
; curr 76564125 index-num-nat 12375 cpt-triangle-nat 76576500 nb-divisors-count 576
; 76576500 which has 576 divisors

;nth-triangle-nat n => (/ (* n (+ n 1)) 2) ; (n^2 + n)/2
;nth-triangle-nat n+1 => (/ (* (+ n 1) (+ n 2)) 2) ; 1/2(n^2 + 3n + 2)
;nth-triangle-nat n+2 => (/ (* (+ n 2) (+ n 3)) 2) ; 1/2(n^2 + 5n + 6)
